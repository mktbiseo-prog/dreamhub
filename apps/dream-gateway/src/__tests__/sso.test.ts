// ---------------------------------------------------------------------------
// SSO Integration Tests
//
// Tests the complete SSO lifecycle:
//   1. Shared JWT — token from one service valid across all services
//   2. USER_REGISTERED → all 4 services create initial records
//   3. USER_UPDATED → all 4 services sync profile changes
//   4. USER_DELETED → all 4 services clean up user data
//   5. Social login SSO flow
//
// Uses the real SSOManager + MemoryEventBus + real service event handlers.
// ---------------------------------------------------------------------------

import { describe, it, expect, beforeEach } from "vitest";
import { MemoryEventBus } from "@dreamhub/event-bus";
import { SSOManager } from "@dreamhub/auth/sso";
import { UserStore } from "@dreamhub/auth/user-store";
import { verifyToken, generateTokens } from "@dreamhub/auth/jwt";

// Service event handlers
import {
  registerBrainEventHandlers,
  getBrainUser,
  getAllBrainUsers,
  resetBrainSSOState,
} from "../../../../apps/dream-brain/src/lib/event-handlers";

import {
  registerPlannerEventHandlers,
  getPlannerUser,
  getAllPlannerUsers,
  resetState as resetPlannerState,
} from "../../../../apps/dream-planner/src/lib/event-handlers";

import {
  registerPlaceEventHandlers,
  getPlaceUser,
  getAllPlaceUsers,
  resetState as resetPlaceState,
} from "../../../../apps/dream-place/src/lib/event-handlers";

import {
  registerStoreEventHandlers,
  getStoreUser,
  getAllStoreUsers,
  resetStoreSSOState,
} from "../../../../apps/dream-store/src/lib/event-handlers";

describe("SSO — Single Sign-On Integration", () => {
  let bus: MemoryEventBus;
  let store: UserStore;
  let sso: SSOManager;

  beforeEach(() => {
    bus = new MemoryEventBus();
    store = new UserStore();
    sso = new SSOManager(bus, store);

    // Reset all service states
    resetBrainSSOState();
    resetPlannerState();
    resetPlaceState();
    resetStoreSSOState();

    // Register all service event handlers on the shared bus
    registerBrainEventHandlers(bus);
    registerPlannerEventHandlers(bus);
    registerPlaceEventHandlers(bus);
    registerStoreEventHandlers(bus);
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // 1. Shared JWT — Cross-Service Token Validity
  // ═══════════════════════════════════════════════════════════════════════════

  describe("Shared JWT Secret", () => {
    it("token generated by auth is valid in all services", async () => {
      const result = await sso.register("alice@example.com", "Password123!", "Alice");

      // The same verifyToken function is used by all services (shared @dreamhub/auth/jwt)
      const brainVerify = verifyToken(result.tokens.accessToken);
      expect(brainVerify.isValid).toBe(true);
      expect(brainVerify.userId).toBe(result.user.id);

      const plannerVerify = verifyToken(result.tokens.accessToken);
      expect(plannerVerify.isValid).toBe(true);
      expect(plannerVerify.userId).toBe(result.user.id);

      const placeVerify = verifyToken(result.tokens.accessToken);
      expect(placeVerify.isValid).toBe(true);
      expect(placeVerify.userId).toBe(result.user.id);

      const storeVerify = verifyToken(result.tokens.accessToken);
      expect(storeVerify.isValid).toBe(true);
      expect(storeVerify.userId).toBe(result.user.id);
    });

    it("verifyAcrossServices confirms cross-service validity", async () => {
      const result = await sso.register("bob@example.com", "Password123!", "Bob");
      const crossCheck = sso.verifyAcrossServices(result.tokens.accessToken);
      expect(crossCheck.isValid).toBe(true);
      expect(crossCheck.userId).toBe(result.user.id);
    });

    it("invalid token is rejected by all services", () => {
      const fakeToken = "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJmYWtlIn0.invalid";
      const result = verifyToken(fakeToken);
      expect(result.isValid).toBe(false);
    });

    it("tokens contain correct permissions", async () => {
      const result = await sso.register("carol@example.com", "Password123!", "Carol");
      const payload = verifyToken(result.tokens.accessToken);
      expect(payload.permissions).toContain("brain:read");
      expect(payload.permissions).toContain("planner:write");
      expect(payload.permissions).toContain("place:read");
      expect(payload.permissions).toContain("store:read");
    });
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // 2. USER_REGISTERED → All Services Create Records
  // ═══════════════════════════════════════════════════════════════════════════

  describe("Registration Propagation", () => {
    it("registers user and creates records in all 4 services", async () => {
      const result = await sso.register("dave@example.com", "Password123!", "Dave");
      const userId = result.user.id;

      expect(result.eventPublished).toBe(true);

      // Brain: empty thought space
      const brainRecord = getBrainUser(userId);
      expect(brainRecord).toBeDefined();
      expect(brainRecord!.thoughts).toBe(0);
      expect(brainRecord!.embedding).toBeNull();
      expect(brainRecord!.name).toBe("Dave");

      // Planner: gritScore=0, currentPart=1
      const plannerRecord = getPlannerUser(userId);
      expect(plannerRecord).toBeDefined();
      expect(plannerRecord!.gritScore).toBe(0);
      expect(plannerRecord!.currentPart).toBe(1);
      expect(plannerRecord!.completionRate).toBe(0);

      // Place: cold-start DNA
      const placeRecord = getPlaceUser(userId);
      expect(placeRecord).toBeDefined();
      expect(placeRecord!.dnaInitialized).toBe(false);
      expect(placeRecord!.coldStartStrategy).toBe("CONTENT_INIT");

      // Store: empty product catalog
      const storeRecord = getStoreUser(userId);
      expect(storeRecord).toBeDefined();
      expect(storeRecord!.products).toBe(0);
      expect(storeRecord!.revenue).toBe(0);
    });

    it("multiple users each get their own records", async () => {
      await sso.register("user1@example.com", "Password123!", "User One");
      await sso.register("user2@example.com", "Password123!", "User Two");
      await sso.register("user3@example.com", "Password123!", "User Three");

      expect(getAllBrainUsers().size).toBe(3);
      expect(getAllPlannerUsers().size).toBe(3);
      expect(getAllPlaceUsers().size).toBe(3);
      expect(getAllStoreUsers().size).toBe(3);
    });

    it("registration with preferred language propagates correctly", async () => {
      const result = await sso.register(
        "korean@example.com",
        "Password123!",
        "Korean User",
        "ko",
      );
      expect(result.user.preferredLanguage).toBe("ko");
    });
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // 3. USER_UPDATED → All Services Sync Changes
  // ═══════════════════════════════════════════════════════════════════════════

  describe("Profile Update Propagation", () => {
    it("name change syncs to all services", async () => {
      const reg = await sso.register("eve@example.com", "Password123!", "Eve");
      const userId = reg.user.id;

      const update = await sso.updateProfile(userId, { name: "Eve Updated" });
      expect(update.eventPublished).toBe(true);
      expect(update.user.name).toBe("Eve Updated");

      // All services reflect the change
      expect(getBrainUser(userId)!.name).toBe("Eve Updated");
      expect(getPlannerUser(userId)!.name).toBe("Eve Updated");
      expect(getPlaceUser(userId)!.name).toBe("Eve Updated");
      expect(getStoreUser(userId)!.name).toBe("Eve Updated");
    });

    it("email change syncs to brain (which tracks email)", async () => {
      const reg = await sso.register("frank@example.com", "Password123!", "Frank");
      const userId = reg.user.id;

      await sso.updateProfile(userId, { email: "frank-new@example.com" });

      expect(getBrainUser(userId)!.email).toBe("frank-new@example.com");
    });

    it("partial update only changes specified fields", async () => {
      const reg = await sso.register("grace@example.com", "Password123!", "Grace");
      const userId = reg.user.id;

      await sso.updateProfile(userId, { name: "Grace Updated" });

      // Auth store email unchanged
      const user = store.findById(userId);
      expect(user!.email).toBe("grace@example.com");
      expect(user!.name).toBe("Grace Updated");
    });

    it("update non-existent user throws error", async () => {
      await expect(
        sso.updateProfile("non-existent-id", { name: "Nobody" }),
      ).rejects.toThrow("User not found");
    });
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // 4. USER_DELETED → All Services Clean Up
  // ═══════════════════════════════════════════════════════════════════════════

  describe("Account Deletion Propagation", () => {
    it("deletes user data from all 4 services", async () => {
      const reg = await sso.register("henry@example.com", "Password123!", "Henry");
      const userId = reg.user.id;

      // Verify records exist
      expect(getBrainUser(userId)).toBeDefined();
      expect(getPlannerUser(userId)).toBeDefined();
      expect(getPlaceUser(userId)).toBeDefined();
      expect(getStoreUser(userId)).toBeDefined();

      // Delete
      const deletion = await sso.deleteAccount(userId);
      expect(deletion.eventPublished).toBe(true);
      expect(deletion.userId).toBe(userId);
      expect(deletion.deletedAt).toBeTruthy();

      // All service records removed
      expect(getBrainUser(userId)).toBeUndefined();
      expect(getPlannerUser(userId)).toBeUndefined();
      expect(getPlaceUser(userId)).toBeUndefined();
      expect(getStoreUser(userId)).toBeUndefined();
    });

    it("deleted user's token is no longer associated with a valid user", async () => {
      const reg = await sso.register("iris@example.com", "Password123!", "Iris");
      const userId = reg.user.id;

      await sso.deleteAccount(userId);

      // Token is still technically valid (JWT is stateless),
      // but user no longer exists in the store
      const payload = verifyToken(reg.tokens.accessToken);
      expect(payload.isValid).toBe(true); // JWT itself is valid
      expect(store.findById(userId)).toBeUndefined(); // But user is gone
    });

    it("delete non-existent user throws error", async () => {
      await expect(sso.deleteAccount("non-existent-id")).rejects.toThrow(
        "User not found",
      );
    });

    it("deleting one user does not affect others", async () => {
      const reg1 = await sso.register("user-a@example.com", "Password123!", "User A");
      const reg2 = await sso.register("user-b@example.com", "Password123!", "User B");

      await sso.deleteAccount(reg1.user.id);

      // User B's records intact
      expect(getBrainUser(reg2.user.id)).toBeDefined();
      expect(getPlannerUser(reg2.user.id)).toBeDefined();
      expect(getPlaceUser(reg2.user.id)).toBeDefined();
      expect(getStoreUser(reg2.user.id)).toBeDefined();
    });
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // 5. Social Login SSO Flow
  // ═══════════════════════════════════════════════════════════════════════════

  describe("Social Login SSO", () => {
    it("new Google user creates records in all services", async () => {
      const result = await sso.socialLogin(
        "google",
        "google-123",
        "social@example.com",
        "Social User",
        "https://example.com/avatar.jpg",
      );

      expect(result.isNewUser).toBe(true);
      expect(result.eventPublished).toBe(true);

      const userId = result.user.id;
      expect(getBrainUser(userId)).toBeDefined();
      expect(getPlannerUser(userId)).toBeDefined();
      expect(getPlaceUser(userId)).toBeDefined();
      expect(getStoreUser(userId)).toBeDefined();
    });

    it("returning social user does NOT re-broadcast registration", async () => {
      const first = await sso.socialLogin(
        "google",
        "google-456",
        "returning@example.com",
        "Returning User",
      );
      expect(first.isNewUser).toBe(true);
      expect(first.eventPublished).toBe(true);

      // Login again — same social account
      const second = await sso.socialLogin(
        "google",
        "google-456",
        "returning@example.com",
        "Returning User",
      );
      expect(second.isNewUser).toBe(false);
      expect(second.eventPublished).toBe(false);

      // Still only 1 record per service
      expect(getAllBrainUsers().size).toBe(1);
    });

    it("social login token is valid across all services", async () => {
      const result = await sso.socialLogin(
        "apple",
        "apple-789",
        "apple@example.com",
        "Apple User",
      );

      const payload = verifyToken(result.tokens.accessToken);
      expect(payload.isValid).toBe(true);
      expect(payload.userId).toBe(result.user.id);
    });
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // 6. Full Lifecycle — Register → Update → Delete
  // ═══════════════════════════════════════════════════════════════════════════

  describe("Full Lifecycle", () => {
    it("complete user journey: register → update → delete", async () => {
      // 1. Register
      const reg = await sso.register("lifecycle@example.com", "Password123!", "Lifecycle User");
      const userId = reg.user.id;

      // Verify initial state in all services
      expect(getBrainUser(userId)!.name).toBe("Lifecycle User");
      expect(getPlannerUser(userId)!.gritScore).toBe(0);
      expect(getPlaceUser(userId)!.coldStartStrategy).toBe("CONTENT_INIT");
      expect(getStoreUser(userId)!.products).toBe(0);

      // 2. Update profile
      await sso.updateProfile(userId, { name: "Updated Name" });
      expect(getBrainUser(userId)!.name).toBe("Updated Name");
      expect(getPlannerUser(userId)!.name).toBe("Updated Name");
      expect(getPlaceUser(userId)!.name).toBe("Updated Name");
      expect(getStoreUser(userId)!.name).toBe("Updated Name");

      // 3. Delete
      await sso.deleteAccount(userId);
      expect(getBrainUser(userId)).toBeUndefined();
      expect(getPlannerUser(userId)).toBeUndefined();
      expect(getPlaceUser(userId)).toBeUndefined();
      expect(getStoreUser(userId)).toBeUndefined();
      expect(store.findById(userId)).toBeUndefined();
    });

    it("10 users register and each has 4 service records", async () => {
      for (let i = 0; i < 10; i++) {
        await sso.register(`user${i}@example.com`, "Password123!", `User ${i}`);
      }

      expect(getAllBrainUsers().size).toBe(10);
      expect(getAllPlannerUsers().size).toBe(10);
      expect(getAllPlaceUsers().size).toBe(10);
      expect(getAllStoreUsers().size).toBe(10);
    });
  });
});
