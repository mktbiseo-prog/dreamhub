generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── Dream ID (Shared Auth) ────────────────────────────────────

model User {
  id             String    @id @default(cuid())
  email          String    @unique
  name           String?
  avatar         String?
  bio            String?   @db.Text
  dreamStatement String?   @db.Text
  skills         String[]  @default([])
  interests      String[]  @default([])
  emailVerified  DateTime?
  hashedPassword String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  dreamProfile  DreamProfile?
  sentMatches   Match[]       @relation("MatchSender")
  receivedMatches Match[]     @relation("MatchReceiver")
  sentMessages  Message[]     @relation("MessageSender")
  thoughts      Thought[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ─── Dream Place ────────────────────────────────────────────

model DreamProfile {
  id              String   @id @default(cuid())
  userId          String   @unique
  dreamStatement  String   @db.Text
  dreamHeadline   String?
  dreamCategory   String?
  skillsOffered   String[] @default([])
  skillsNeeded    String[] @default([])
  interests       String[] @default([])
  city            String?
  country         String?
  remotePreference String?  // "remote" | "local" | "hybrid"
  commitmentLevel  String?  // "full-time" | "part-time" | "weekends" | "flexible"
  experienceLevel  String?  // "student" | "early-career" | "mid-career" | "senior" | "executive"
  avatarUrl       String?
  bio             String?  @db.Text
  embedding       Float[]  @default([])
  onboardingCompleted Boolean @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("dream_profiles")
}

enum MatchStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

model Match {
  id            String      @id @default(cuid())
  senderId      String
  receiverId    String
  matchScore    Float       @default(0)
  dreamScore    Float       @default(0)
  skillScore    Float       @default(0)
  valueScore    Float       @default(0)
  status        MatchStatus @default(PENDING)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  sender   User @relation("MatchSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("MatchReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  messages Message[]

  @@unique([senderId, receiverId])
  @@map("matches")
}

model Message {
  id        String   @id @default(cuid())
  matchId   String
  senderId  String
  content   String   @db.Text
  createdAt DateTime @default(now())

  match  Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender User  @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

// ─── Dream Store ─────────────────────────────────────────────

model DreamStory {
  id        String   @id @default(cuid())
  userId    String
  title     String
  statement String   @db.Text
  coverImage String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  milestones Milestone[]
  products   Product[]

  @@map("dream_stories")
}

model Milestone {
  id           String   @id @default(cuid())
  dreamStoryId String
  title        String
  targetDate   DateTime
  completed    Boolean  @default(false)
  sortOrder    Int      @default(0)
  createdAt    DateTime @default(now())

  dreamStory DreamStory @relation(fields: [dreamStoryId], references: [id], onDelete: Cascade)

  @@map("milestones")
}

model Product {
  id           String   @id @default(cuid())
  dreamStoryId String
  title        String
  description  String   @db.Text
  price        Int      // cents
  images       String[] @default([])
  whyIMadeThis String?  @db.Text
  category     String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  dreamStory DreamStory @relation(fields: [dreamStoryId], references: [id], onDelete: Cascade)

  @@map("products")
}

// ─── Dream Brain ─────────────────────────────────────────────

enum ThoughtCategory {
  WORK
  IDEAS
  EMOTIONS
  DAILY
  LEARNING
  RELATIONSHIPS
  HEALTH
  FINANCE
  DREAMS
}

enum InputMethod {
  TEXT
  VOICE
}

model Thought {
  id                  String          @id @default(cuid())
  userId              String
  title               String
  body                String          @db.Text
  summary             String?         @db.Text
  category            ThoughtCategory @default(IDEAS)
  tags                String[]        @default([])
  keywords            String[]        @default([])
  importance          Int             @default(3)
  inputMethod         InputMethod     @default(TEXT)
  voiceFileUrl        String?
  voiceDurationSeconds Int?
  isFavorite          Boolean         @default(false)
  isArchived          Boolean         @default(false)
  isPinned            Boolean         @default(false)
  embedding           Float[]         @default([])
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  user                User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  connectionsFrom     ThoughtConnection[] @relation("ConnectionSource")
  connectionsTo       ThoughtConnection[] @relation("ConnectionTarget")

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, category])
  @@map("thoughts")
}

model ThoughtConnection {
  id              String  @id @default(cuid())
  sourceThoughtId String
  targetThoughtId String
  score           Float   @default(0)
  reason          String? @db.Text
  createdAt       DateTime @default(now())

  sourceThought   Thought @relation("ConnectionSource", fields: [sourceThoughtId], references: [id], onDelete: Cascade)
  targetThought   Thought @relation("ConnectionTarget", fields: [targetThoughtId], references: [id], onDelete: Cascade)

  @@unique([sourceThoughtId, targetThoughtId])
  @@map("thought_connections")
}
