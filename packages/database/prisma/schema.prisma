generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── Dream ID (Shared Auth) ────────────────────────────────────

model User {
  id             String    @id @default(cuid())
  email          String    @unique
  name           String?
  avatar         String?
  bio            String?   @db.Text
  dreamStatement String?   @db.Text
  skills         String[]  @default([])
  interests      String[]  @default([])
  emailVerified  DateTime?
  hashedPassword String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  stripeCustomerId String?
  stripeConnectId  String?

  accounts      Account[]
  sessions      Session[]
  dreamProfile  DreamProfile?
  sentMatches   Match[]       @relation("MatchSender")
  receivedMatches Match[]     @relation("MatchReceiver")
  sentMessages  Message[]     @relation("MessageSender")
  thoughts      Thought[]
  insightReports InsightReport[]
  dreamStories  DreamStory[]
  orders        Order[]
  following     Follow[]
  dreamUpdates  DreamUpdate[] @relation("DreamUpdates")

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ─── Dream Place ────────────────────────────────────────────

model DreamProfile {
  id              String   @id @default(cuid())
  userId          String   @unique
  dreamStatement  String   @db.Text
  dreamHeadline   String?
  dreamCategory   String?
  skillsOffered   String[] @default([])
  skillsNeeded    String[] @default([])
  interests       String[] @default([])
  city            String?
  country         String?
  remotePreference String?  // "remote" | "local" | "hybrid"
  commitmentLevel  String?  // "full-time" | "part-time" | "weekends" | "flexible"
  experienceLevel  String?  // "student" | "early-career" | "mid-career" | "senior" | "executive"
  avatarUrl       String?
  bio             String?  @db.Text
  embedding       Float[]  @default([])
  onboardingCompleted Boolean @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("dream_profiles")
}

enum MatchStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

model Match {
  id            String      @id @default(cuid())
  senderId      String
  receiverId    String
  matchScore    Float       @default(0)
  dreamScore    Float       @default(0)
  skillScore    Float       @default(0)
  valueScore    Float       @default(0)
  status        MatchStatus @default(PENDING)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  sender   User @relation("MatchSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("MatchReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  messages Message[]

  @@unique([senderId, receiverId])
  @@map("matches")
}

model Message {
  id        String   @id @default(cuid())
  matchId   String
  senderId  String
  content   String   @db.Text
  createdAt DateTime @default(now())

  match  Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender User  @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

// ─── Dream Store ─────────────────────────────────────────────

model DreamStory {
  id        String   @id @default(cuid())
  userId    String
  title     String
  statement String   @db.Text
  coverImage String?
  category   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  milestones Milestone[]
  products   Product[]
  orders     Order[]
  followers  Follow[]
  updates    DreamUpdate[]

  @@index([userId])
  @@map("dream_stories")
}

model Milestone {
  id           String   @id @default(cuid())
  dreamStoryId String
  title        String
  targetDate   DateTime
  completed    Boolean  @default(false)
  sortOrder    Int      @default(0)
  createdAt    DateTime @default(now())

  dreamStory DreamStory @relation(fields: [dreamStoryId], references: [id], onDelete: Cascade)

  @@map("milestones")
}

model Product {
  id           String   @id @default(cuid())
  dreamStoryId String
  title        String
  description  String   @db.Text
  price        Int      // cents
  images       String[] @default([])
  whyIMadeThis String?  @db.Text
  category     String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  dreamStory DreamStory @relation(fields: [dreamStoryId], references: [id], onDelete: Cascade)
  orders     Order[]

  @@map("products")
}

enum OrderStatus {
  PENDING
  COMPLETED
  REFUNDED
  FAILED
}

model Order {
  id               String      @id @default(cuid())
  buyerId          String
  productId        String
  dreamStoryId     String
  amount           Int         // cents
  stripeFee        Int         @default(0)
  platformFee      Int         @default(0)
  creatorPayout    Int         @default(0)
  stripeSessionId  String?     @unique
  stripePaymentId  String?
  status           OrderStatus @default(PENDING)
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  buyer      User       @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  product    Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  dreamStory DreamStory @relation(fields: [dreamStoryId], references: [id], onDelete: Cascade)

  @@index([buyerId])
  @@index([dreamStoryId])
  @@map("orders")
}

model Follow {
  id           String   @id @default(cuid())
  followerId   String
  dreamStoryId String
  createdAt    DateTime @default(now())

  follower   User       @relation(fields: [followerId], references: [id], onDelete: Cascade)
  dreamStory DreamStory @relation(fields: [dreamStoryId], references: [id], onDelete: Cascade)

  @@unique([followerId, dreamStoryId])
  @@map("follows")
}

model DreamUpdate {
  id           String   @id @default(cuid())
  dreamStoryId String
  userId       String
  title        String
  content      String   @db.Text
  images       String[] @default([])
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  dreamStory DreamStory @relation(fields: [dreamStoryId], references: [id], onDelete: Cascade)
  user       User       @relation("DreamUpdates", fields: [userId], references: [id], onDelete: Cascade)

  @@index([dreamStoryId, createdAt(sort: Desc)])
  @@map("dream_updates")
}

// ─── Dream Brain ─────────────────────────────────────────────

enum ThoughtCategory {
  WORK
  IDEAS
  EMOTIONS
  DAILY
  LEARNING
  RELATIONSHIPS
  HEALTH
  FINANCE
  DREAMS
}

enum InputMethod {
  TEXT
  VOICE
}

model Thought {
  id                  String          @id @default(cuid())
  userId              String
  title               String
  body                String          @db.Text
  summary             String?         @db.Text
  category            ThoughtCategory @default(IDEAS)
  tags                String[]        @default([])
  keywords            String[]        @default([])
  importance          Int             @default(3)
  inputMethod         InputMethod     @default(TEXT)
  voiceFileUrl        String?
  voiceDurationSeconds Int?
  isFavorite          Boolean         @default(false)
  isArchived          Boolean         @default(false)
  isPinned            Boolean         @default(false)
  emotion              String?
  emotionSecondary     String?
  valence              Float?          @default(0)
  emotionConfidence    Float?          @default(0)
  actionItems          Json?           @default("[]")
  peopleMentioned      String[]        @default([])
  placesMentioned      String[]        @default([])
  embedding           Float[]         @default([])
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  user                User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  connectionsFrom     ThoughtConnection[] @relation("ConnectionSource")
  connectionsTo       ThoughtConnection[] @relation("ConnectionTarget")

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, category])
  @@map("thoughts")
}

model ThoughtConnection {
  id              String  @id @default(cuid())
  sourceThoughtId String
  targetThoughtId String
  score           Float   @default(0)
  reason          String? @db.Text
  createdAt       DateTime @default(now())

  sourceThought   Thought @relation("ConnectionSource", fields: [sourceThoughtId], references: [id], onDelete: Cascade)
  targetThought   Thought @relation("ConnectionTarget", fields: [targetThoughtId], references: [id], onDelete: Cascade)

  @@unique([sourceThoughtId, targetThoughtId])
  @@map("thought_connections")
}

model InsightReport {
  id          String   @id @default(cuid())
  userId      String
  periodType  String   // "weekly" | "monthly"
  periodStart DateTime
  periodEnd   DateTime
  content     Json
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, periodType, periodStart])
  @@map("insight_reports")
}
